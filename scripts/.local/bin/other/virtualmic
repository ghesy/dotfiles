#!/bin/sh
# setup a LAN audio stream as a microphone for pulseaudio.
# requires: dmenu, ffmpeg.

# config
NAME=VirtualMic
PIDFILE=${XDG_RUNTIME_DIR:?}/virtualmic
DIR=${XDG_CACHE_HOME:-$HOME/.cache}/virtualmic

main() {
    if [ -f "${PIDFILE:?}" ]; then
        case $(printf 'No\nYes\n' | dmenu -p 'Disconnect?') in
            Yes) pkill -F "${PIDFILE:?}" ;;
        esac
    else
        connect_lan
    fi
}

connect_lan() {
    host=$(ask_host) || return 1
    connect "$host"
}

connect()
{
    trap 'notify-send -u low virtualmic "could not connect."' EXIT
    configure_pulse_module

    # detect the host's protocol
    host=$(curl -Isw'\n %{exitcode} %{url}\n' "{rtsp,https,http}://${1:?}" |
        grep ' 0 ' | cut -d' ' -f3)

    # start ffplay
    ffplay -nodisp -loglevel quiet "${host:?}" &
    ffplay_pid=$!
    echo "$ffplay_pid" > "${PIDFILE:?}"

    # cleanup upon failure
    ( (
        pwait -F "${PIDFILE:?}"
        pacmd unload-module "$module"
        rm "${PIDFILE:?}"
        notify-send virtualmic disconnected.
    ) & ) >/dev/null 2>&1
    trap 'kill $ffplay_pid' EXIT

    # get ffplay's sink-input as soon as it appears
    i=0
    until ffplay_input=$(pacmd list-sink-inputs | get_index_by_pid "$ffplay_pid"); do
        sleep 0.2
        i=$((i+1))
        [ $i -gt 80 ] && exit 6
    done

    # change ffplay's sink-input's name
    pacmd update-sink-input-proplist "$ffplay_input" media.name="$NAME"

    # move ffplay's sink-input to remap's sink.
    stream_restore_module=$(pactl list short modules | grep module-stream-restore | cut -f2-)
    [ -n "$stream_restore_module" ] && pacmd unload-module module-stream-restore
    pacmd move-sink-input "$ffplay_input" "$module_sink" || exit 7
    [ -n "$stream_restore_module" ] && eval pacmd load-module "${stream_restore_module:?}"

    # make remap's source the default.
    pacmd set-default-source "$module_source" || exit 8

    # notify the success.
    notify-send -u low virtualmic connected.

    # clear the trap
    trap - EXIT
}

configure_pulse_module()
{
    # load the remap-sink module
    module=$(pactl load-module module-remap-sink \
        sink_name="$NAME" sink_properties=device.description="$NAME") || exit 2

    # get the modules's sink-input, then mute it and change it's name
    module_input=$(pacmd list-sink-inputs | get_index_by_module "${module:?}") || exit 3
    pacmd set-sink-input-mute "$module_input" 1
    pacmd update-sink-input-proplist "$module_input" media.name="$NAME"

    # get the module's sink
    module_sink=$(pacmd list-sinks | get_index_by_module "${module:?}") || exit 4

    # get the module's source and change it's class and name
    module_source=$(pacmd list-sources | get_index_by_module "${module:?}") || exit 5
    pacmd update-source-proplist "$module_source" device.description="$NAME" device.class=sound
}

ask_host() {
    last_ip=${DIR:?}/last-ip last_port=${DIR:?}/last-port
    mkdir -pm700 "${DIR:?}"
    touch "$last_ip" "$last_port"

    ip=$(dmenu -p 'Enter IP or Host (no port)' < "$last_ip") || return 1
    port=$(dmenu -p 'Enter Port' < "$last_port") || return 1

    echo "${ip:?}" > "$last_ip"
    echo "${port:?}" > "$last_port"

    echo "$ip:$port"
}

get_index_by_module() {
    tac | tr '\n' ' ' | grep -Po "\tmodule: \Q${1:?}\E .*?index: \K\d+"
}

get_index_by_pid() {
    tac | tr '\n' ' ' | grep -Po "\Qapplication.process.id = \"${1:?}\"\E .*?index: \K\d+"
}

main "$@"
