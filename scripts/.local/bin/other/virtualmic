#!/bin/sh
# detect an audio stream on the local network or on an android phone
# connected via cable through adb, and set it up as a pulseaudio input device.
# requires GNU coreutils, mpv, libnotify, curl, android-tools (for wired connection using adb).

# config
PORT=8080
subnet=$(set -- $(ip r); echo "${3%.*}")
HOST=http://${subnet:?}.[0-255]:${PORT:?}
PIDFILE=${XDG_RUNTIME_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}}/virtualmic.pid
NAME=VirtualMic

# if virtualmicmic is already running, kill and cleanup everything and exit.
if [ -e "${PIDFILE:?}" ]; then
    pkill -F "${PIDFILE:?}"
    exit
elif pidof -qxo%PPID "${0##*/}"; then
    notify-send -u low virtualmic "Another instance is trying to connect."
    exit
fi

# notify the failure.
trap 'notify-send -u low virtualmic "Could not connect."' EXIT

# find the host using curl.
host=$(curl -ZIsw'\n%{content_type} %{url}\n' --connect-timeout 0.5 -m3 \
    --parallel-max 25 -- "${HOST:?}" | grep -Pom1 '^audio/\S+ \K.*')
# if not found, try finding it using adb.
[ -z "$host" ] && host=$(
    command -v adb >/dev/null || exit 1
    for dev in $(adb devices | sed 1d | cut -f1); do
        p=$(adb -s "$dev" forward tcp:0 tcp:"${PORT:?}") || continue
        curl -Isw'\n%{content_type} %{url}\n' --connect-timeout 0.5 -m3 \
            "http://localhost:$p" | grep -Pom1 '^audio/\S+ \K.*' ||
            adb -s "$dev" forward --remove tcp:$p
    done
)
# if not found, exit.
[ -z "$host" ] && exit 1

# load the remap-sink module.
module=$(pactl load-module module-remap-sink \
    sink_name="$NAME" sink_properties=device.description="$NAME") || exit 2

# get remap's sink input, then mute it and change it's name.
module_input=$(pactl list sink-inputs | tac | tr '\n' ' ' |
    grep -Po "Owner Module: ${module:?}\s.*?Sink Input #\K\d+") || exit 3
pactl set-sink-input-mute "$module_input" 1
pacmd update-sink-input-proplist "$module_input" media.name="$NAME"

# get remap's sink.
module_sink=$(pactl list sinks | tac | tr '\n' ' ' |
    grep -Po "Owner Module: ${module:?}\s.*?Sink #\K\d+") || exit 4

# get remap's source and change it's class and name.
module_source=$(pactl list sources | tac | tr '\n' ' ' |
    grep -Po "Owner Module: ${module:?}\s.*?Source #\K\d+") || exit 5
pacmd update-source-proplist "$module_source" device.class=sound
pacmd update-source-proplist "$module_source" device.description="$NAME"

# start mpv.
mpv --no-config --load-scripts=no --no-terminal --audio-client-name="$NAME" \
    --no-video --profile=low-latency --no-cache -- "$host" >/dev/null 2>&1 &
mpv_pid=$!
echo "$mpv_pid" > "${PIDFILE:?}"
sleep 2

# cleanup upon failure.
( (pwait -F "${PIDFILE:?}"; pactl unload-module "$module"
    rm "${PIDFILE:?}"; notify-send virtualmic Disconnected.)&) >/dev/null 2>&1
trap 'kill $mpv_pid' EXIT

# get mpv's sink input.
mpv_input=$(pactl list sink-inputs | tac | tr '\n' ' ' |
    grep -Po "application\.process\.id = \"${mpv_pid:?}\"\s.*?Sink Input #\K\d+") || exit 6

# move mpv's sink input to remap's sink.
pactl move-sink-input "$mpv_input" "$module_sink" || exit 7

# make remap's source the default.
pactl set-default-source "$module_source" || exit 8

# notify the success.
notify-send -u low virtualmic Connected.

# if "module-stream-restore" is loaded, add the "restore_device=false" option to it,
# to prevent this module from moving all mpv inputs under the remap module's sink.
args=$(pactl list short modules | grep module-stream-restore | cut -f2- |
    grep -v 'restore_device=false' | sed 's/$/restore_device=false/')
[ -n "$args" ] && pactl unload-module module-stream-restore &&
    pactl load-module $args >/dev/null

# clear the trap.
trap - EXIT
